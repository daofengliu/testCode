package idv.spring.ioc.ch03javaconfig;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;
import org.springframework.context.annotation.*;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * ==== Java-based Container Configuration ====
 * Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework.
 * Thus, you can define beans external to your application classes by using Java rather than XML files.
 * To use these new features, see the @Configuration, @Bean, @Import, and @DependsOn, ... annotations.
 * _Spring 3.0 開始，支援使用 Java class 取代 XML 的方式設定 Spring bean
 *
 * ==== @Configuration ====
 * Used to indicate that a class declares one or more @Bean methods.
 * These classes are processed by the Spring container to generate bean definitions and service requests for those beans at runtime.
 *
 * An application may make use of just one @Configuration-annotated class, or many.
 * @Configuration can be considered the equivalent of XML's <beans/> element.
 * Like <beans/>, it provides an opportunity to explicitly set defaults for all enclosed bean definitions.
 * _一個 application 可以有一或多個以 @Configuration 宣告的設定檔 (多個 application context)
 * _@Configuration 相當於 XML 設定檔的 <beans/> 元素
 *
 * ps. @Configuration is meta-annotated with @Component, therefore @Configuration classes are candidates for component scanning
 *     _@Configuration 被 @Component 標註，所以具備有 @Component 的行為
 *
 *
 * ==== @Bean ====
 * Indicates that a method produces a bean to be managed by the Spring container.
 * This is one of the most used and important spring annotation.
 * @Bean annotation also can be used with parameters like name, initMethod and destroyMethod.
 *
 *
 * The @Bean annotation supports specifying arbitrary initialization and destruction callback methods,
 *   much like Spring XML's init-method and destroy-method attributes to the bean element:
 *
 *   @Bean(initMethod = "init", destroyMethod = "destroy", autowire = Autowire.BY_NAME)
 *
 *   == Profile, Scope, Lazy, DependsOn, Primary, Order ==
 *   Note that the @Bean annotation does not provide attributes for profile, scope, lazy, depends-on or primary.
 *   Rather, it should be used in conjunction with @Scope, @Lazy, @DependsOn and @Primary annotations to declare those semantics.
 *
 *
 * ==== Receiving lifecycle callbacks ====
 * Spring supports JSR 250 Annotations such as @PostConstruct, @PreDestroy and @Resource annotations.
 *
 *
 * == Using Spring interfaces ==
 * Spring's lifecycle callbacks are fully supported.
 * If a bean implements InitializingBean, DisposableBean, or Lifecycle, their respective methods will be called by the container in accordance with their Javadoc.
 *
 * == Using *Aware interfaces ==
 * The standard set of *Aware interfaces such as BeanFactoryAware, BeanNameAware, MessageSourceAware, ApplicationContextAware, etc. are fully supported.
 *
 *
 * ==== Bootstrapping @Configuration classes ====
 * 1. via AnnotationConfigApplicationContext
 *     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
 *     ctx.register(AppConfig.class);
 *     ctx.refresh();
 *     MyBean myBean = ctx.getBean(MyBean.class);
 *
 * 2. via Spring <beans> XML
 *     <beans>
 *         <context:annotation-config />
 *         <bean class="idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext" />
 *     </beans>
 *
 * 3. via component scanning
 *     @Configuration
 *     @ComponentScan("idv.spring.ioc.ch03javaconfig")
 *     public class AppConfig {
 *         // various @Bean definitions ...
 *     }
 *
 * ==== Working with externalized values ====
 * 1. using the Environment API
 *     @Configuration
 *     @PropertySource("classpath:/idv/spring/ioc/ch03javaconfig")
 *     public class AppConfig {
 *         @Inject Environment env;
 *
 *         @Bean
 *         public MyBean myBean() {
 *             return new MyBean(env.getProperty("bean.name"));
 *         }
 *     }
 *
 * 2. using the @Value annotation
 *     @Configuration
 *     @PropertySource("classpath:/com/acme/app.properties")
 *     public class AppConfig {
 *         @Value("${bean.name}")
 *         String beanName;
 *
 *         @Bean
 *         public MyBean myBean() {
 *             return new MyBean(beanName);
 *         }
 *     }
 *
 * ==== Composing @Configuration classes ====
 * 1. with Spring XML using the @ImportResource annotation
 *     @Configuration
 *     @ImportResource("classpath:/com/acme/database-config.xml")
 *     public class AppConfig {
 *         @Inject
 *         DataSource dataSource; // from XML
 *
 *         @Bean
 *         public MyBean myBean() {
 *             // inject the XML-defined dataSource bean
 *             return new MyBean(this.dataSource);
 *         }
 *     }
 *
 * 2. with the @Import annotation
 *     @Configuration
 *     public class DatabaseConfig {
 *         @Bean
 *         public DataSource dataSource() {
 *             // instantiate, configure and return DataSource
 *         }
 *     }
 *     @Configuration
 *     @Import(DatabaseConfig.class)
 *     public class AppConfig {
 *         @Inject
 *         DatabaseConfig dataConfig;
 *
 *         @Bean
 *         public MyBean myBean() {
 *             // reference the dataSource() bean method
 *             return new MyBean(dataConfig.dataSource());
 *         }
 *     }
 *
 * 3. with the @Profile annotation
 *     @Profile("embedded")
 *     @Configuration
 *     public class EmbeddedDatabaseConfig {
 *         @Bean
 *         public DataSource dataSource() {
 *             // instantiate, configure and return embedded DataSource
 *         }
 *     }
 *     @Profile("production")
 *     @Configuration
 *     public class ProductionDatabaseConfig {
 *         @Bean
 *         public DataSource dataSource() {
 *             // instantiate, configure and return production DataSource
 *         }
 *     }
 *
 * 4. with nested @Configuration classes
 *      @Configuration
 *      public class AppConfig {
 *          @Inject
 *          DataSource dataSource;
 *
 *          @Bean
 *          public MyBean myBean() {
 *              return new MyBean(dataSource);
 *          }
 *
 *          @Configuration
 *          static class DatabaseConfig {
 *              @Bean
 *              DataSource dataSource() {
 *                  return new EmbeddedDatabaseBuilder().build();
 *              }
 *          }
 *      }
 */
@Configuration("appConfig")
//@ImportResource({"classpath:idv/spring/ioc/ch01xml/beansConfig.xml"})
//@PropertySource({"classpath:idv/spring/ioc/ch01xml/jdbc.properties"})
//@Import({BeanConfig.class})
//@ComponentScan(basePackages = "idv.spring.ioc.model")
public class MyJavaBasedApplicationContext {
    private static final Logger LOGGER = LoggerFactory.getLogger(MyJavaBasedApplicationContext.class);

    /**
     * == Xml based spring ==
     * org.springframework.context.support.ClassPathXmlApplicationContext
     *
     * == Java based spring ==
     * org.springframework.context.annotation.AnnotationConfigApplicationContext
     */
    public static void main(String[] args) {
        new MyJavaBasedApplicationContext().testCompnonetScan();
    }

    /**
     * @Configuration("appConfig")
     * @ImportResource({"classpath:idv/spring/ioc/ch01xml/beansConfig.xml"})
     * public class MyJavaBasedApplicationContext {...}
     *
     * org.springframework.context.support.AbstractApplicationContext.prepareRefresh(AbstractApplicationContext.java:589) - Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@1b40d5f0: startup date [Fri May 24 14:26:43 CST 2019]; root of context hierarchy
     * org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:316) - Loading XML bean definitions from class path resource [idv/spring/ioc/ch01xml/beansConfig.xml]
     * org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.<init>(AutowiredAnnotationBeanPostProcessor.java:154) - JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
     * idv.spring.ioc.ch01xml.MyXmlApplicationContext$Singleton.<init>(MyXmlApplicationContext.java:462) - ==== Singleton default constructor ====
     * idv.spring.ioc.ch01xml.MyXmlApplicationContext$Eager.<init>(MyXmlApplicationContext.java:480) - ==== Eager default constructor ====
     * idv.spring.ioc.ch01xml.MyXmlApplicationContext$LifeCycle.<init>(MyXmlApplicationContext.java:542) - ==== LifeCycle constructor ====
     * idv.spring.ioc.ch01xml.MyXmlApplicationContext$LifeCycle.afterPropertiesSet(MyXmlApplicationContext.java:546) - ==== LifeCycle afterPropertiesSet() ====
     * idv.spring.ioc.ch01xml.MyXmlApplicationContext$LifeCycle.<init>(MyXmlApplicationContext.java:542) - ==== LifeCycle constructor ====
     * idv.spring.ioc.ch01xml.MyXmlApplicationContext$LifeCycle.afterPropertiesSet(MyXmlApplicationContext.java:546) - ==== LifeCycle afterPropertiesSet() ====
     * idv.spring.ioc.ch01xml.MyXmlApplicationContext$LifeCycle.doInit(MyXmlApplicationContext.java:554) - ==== LifeCycle doInit() ====
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testImportResource(MyJavaBasedApplicationContext.java:242) - bean name = org.springframework.context.annotation.internalConfigurationAnnotationProcessor
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testImportResource(MyJavaBasedApplicationContext.java:242) - bean name = org.springframework.context.annotation.internalAutowiredAnnotationProcessor
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testImportResource(MyJavaBasedApplicationContext.java:242) - bean name = org.springframework.context.annotation.internalRequiredAnnotationProcessor
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testImportResource(MyJavaBasedApplicationContext.java:242) - bean name = org.springframework.context.annotation.internalCommonAnnotationProcessor
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testImportResource(MyJavaBasedApplicationContext.java:242) - bean name = org.springframework.context.event.internalEventListenerProcessor
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testImportResource(MyJavaBasedApplicationContext.java:242) - bean name = org.springframework.context.event.internalEventListenerFactory
     * ----------------------------------------------------------------------------------------------------------------------------------------------
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testImportResource(MyJavaBasedApplicationContext.java:242) - bean name = appConfig
     * ----------------------------------------------------------------------------------------------------------------------------------------------
     * ...                                                                                                                      ...
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testImportResource(MyJavaBasedApplicationContext.java:242) - bean name = constructorInjection1
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testImportResource(MyJavaBasedApplicationContext.java:242) - bean name = lifecycle2
     * org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:989) - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@1b40d5f0: startup date [Fri May 24 14:26:43 CST 2019]; root of context hierarchy
     * idv.spring.ioc.ch01xml.MyXmlApplicationContext$LifeCycle.destroy(MyXmlApplicationContext.java:550) - ==== LifeCycle destroy() ====
     * idv.spring.ioc.ch01xml.MyXmlApplicationContext$LifeCycle.doDestroy(MyXmlApplicationContext.java:557) - ==== LifeCycle doDestroy() ====
     * idv.spring.ioc.ch01xml.MyXmlApplicationContext$LifeCycle.destroy(MyXmlApplicationContext.java:550) - ==== LifeCycle destroy() ====
     *
     * _由 log 可知，使用 @Configuration 標註的 MyJavaBasedApplicationContext 也會被建立為 Spring bean
     *   _(@Configuration is meta-annotated with @Component)
     */
    public void testAnnoImportResource() {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(MyJavaBasedApplicationContext.class);
        ctx.refresh();
        for (String beanName : ctx.getBeanDefinitionNames()) {
            LOGGER.info("bean name = " + beanName);
        }
        ctx.close();
    }

    /**
     * @Configuration("appConfig")
     * @Import({BeanConfig.class})
     * public class MyJavaBasedApplicationContext {...}
     *
     * org.springframework.context.support.AbstractApplicationContext.prepareRefresh(AbstractApplicationContext.java:589) - Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@1b40d5f0: startup date [Fri May 24 14:32:16 CST 2019]; root of context hierarchy
     * org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.<init>(AutowiredAnnotationBeanPostProcessor.java:154) - JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testAnnoImport(MyJavaBasedApplicationContext.java:270) - bean name = org.springframework.context.annotation.internalConfigurationAnnotationProcessor
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testAnnoImport(MyJavaBasedApplicationContext.java:270) - bean name = org.springframework.context.annotation.internalAutowiredAnnotationProcessor
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testAnnoImport(MyJavaBasedApplicationContext.java:270) - bean name = org.springframework.context.annotation.internalRequiredAnnotationProcessor
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testAnnoImport(MyJavaBasedApplicationContext.java:270) - bean name = org.springframework.context.annotation.internalCommonAnnotationProcessor
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testAnnoImport(MyJavaBasedApplicationContext.java:270) - bean name = org.springframework.context.event.internalEventListenerProcessor
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testAnnoImport(MyJavaBasedApplicationContext.java:270) - bean name = org.springframework.context.event.internalEventListenerFactory
     * -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testAnnoImport(MyJavaBasedApplicationContext.java:270) - bean name = appConfig
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testAnnoImport(MyJavaBasedApplicationContext.java:270) - bean name = idv.spring.ioc.ch03javaconfig.BeanConfig
     * -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testAnnoImport(MyJavaBasedApplicationContext.java:270) - bean name = employeeService
     * idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.testAnnoImport(MyJavaBasedApplicationContext.java:270) - bean name = employeeDao
     * org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:989) - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@1b40d5f0: startup date [Fri May 24 14:32:16 CST 2019]; root of context hierarchy
     *
     * _由 log 可知，使用 @Configuration 標註的 MyJavaBasedApplicationContext 和 BeanConfig 也會被建立為 Spring bean
     *   _(@Configuration is meta-annotated with @Component)
     */
    public void testAnnoImport() {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(MyJavaBasedApplicationContext.class);
        ctx.refresh();
        for (String beanName : ctx.getBeanDefinitionNames()) {
            LOGGER.info("bean name = " + beanName);
        }
        ctx.close();
    }

    /**
     * @Configuration("appConfig")
     * @PropertySource({"classpath:idv/spring/ioc/ch01xml/jdbc.properties"})
     * public class MyJavaBasedApplicationContext {
     *     @Autowired
     *     private Environment env;
     *
     *     @Bean
     *     public DataSource myDataSource() {
     *         BasicDataSource ds = new BasicDataSource();
     *         ds.setDriverClassName(env.getProperty("jdbc.driverClassName"));
     *         ds.setUrl(env.getProperty("jdbc.url"));
     *         ds.setUsername(env.getProperty("jdbc.username"));
     *         ds.setPassword(env.getProperty("jdbc.password"));
     *         return ds;
     *     }
     * }
     * _測試結果，ds 的 driverClassName, url, username, password, ... 成功被 env 設定 jdbc.properties 的值
     *
     * @Configuration("appConfig")
     * @PropertySource({"classpath:idv/spring/ioc/ch01xml/jdbc.properties"})
     * public class MyJavaBasedApplicationContext {
     *     @Value("${jdbc.driverClassName}")
     *     private String jdbcDriver;
     *     @Value("${jdbc.url}")
     *     private String jdbcUrl;
     *     @Value("${jdbc.username}")
     *     private String jdbcUser;
     *
     *     @Bean
     *     public DataSource myDataSource() {
     *         BasicDataSource ds = new BasicDataSource();
     *         ds.setDriverClassName(jdbcDriver);
     *         ds.setUrl(jdbcUrl);
     *         ds.setUsername(jdbcUser);
     *         ds.setPassword(jdbcPw);
     *         return ds;
     *     }
     * }
     * _測試結果，appCfg 的 jdbcDriver, jdbcUrl, jdbcUser, ... 成功被 @Value 設定 jdbc.properties 的值
     */
//    public void testPropertySource() {
//        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
//        ctx.register(MyJavaBasedApplicationContext.class);
//        ctx.refresh();
//        MyJavaBasedApplicationContext appCfg = ctx.getBean("appConfig", MyJavaBasedApplicationContext.class);
//        DataSource ds = ctx.getBean("myDataSource", DataSource.class);
//        ctx.close();
//    }
//    @Autowired
//    private Environment env;
//    @Value("${jdbc.driverClassName}")
//    private String jdbcDriver;
//    @Value("${jdbc.url}")
//    private String jdbcUrl;
//    @Value("${jdbc.username}")
//    private String jdbcUser;


    /**
     * @Configuration("appConfig")
     * @ComponentScan(basePackages = "idv.spring.ioc.model")
     * public class MyJavaBasedApplicationContext {
     *     @Autowired
     *     private Environment env;
     *
     *     @Bean
     *     public DataSource myDataSource() {
     *         BasicDataSource ds = new BasicDataSource();
     *         ds.setDriverClassName(env.getProperty("jdbc.driverClassName"));
     *         ds.setUrl(env.getProperty("jdbc.url"));
     *         ds.setUsername(env.getProperty("jdbc.username"));
     *         ds.setPassword(env.getProperty("jdbc.password"));
     *         return ds;
     *     }
     * }
     * _使用 @Bean 等同在 XML 使用 <bean class="..." /> 宣告的 bean
     * _若有大量的 bean，避免每個都要手動宣告，Spring 提供 @Component 機制
     * _@see idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext2
     *
     * _使用 @Configuration 在不同 package，使用 @Component, @Repository, @Service 註解的 bean
     * _必須要使用 @ComponentScan(basePackages = ${package})，讓 Spring container 去建立這些 bean
     * _和 @Configuration 註解的 class，相同 package 的 @Component bean 可以不用 @ComponentScan
     * _@ComponentScan 就是 XML 宣告的 <context:component-scan>
     *
     * ps. 執行此範例，需要在 idv.spring.ioc.model 建立
     *       @Component("car")
     *       public static class Car {
     *           private Engine engine;
     *           public Car(Engine engine) {
     *               this.engine = engine;
     *           }
     *       }
     */
    public void testCompnonetScan() {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(MyJavaBasedApplicationContext.class);
        ctx.refresh();
        Engine v8Engine = ctx.getBean("v8Engine", Engine.class);
//        Car car = ctx.getBean("car", Car.class);
        ctx.close();
    }

    /********** beans definition **********/
    @Bean
    public Engine v8Engine() {
        return new Engine("v8");
    }

    /**
     * _使用 @PropertySource 設定 bean 的值 ()
     */
//    @Bean
//    public DataSource myDataSource() {
//        BasicDataSource ds = new BasicDataSource();
//        ds.setDriverClassName(env.getProperty("jdbc.driverClassName"));
//        ds.setUrl(env.getProperty("jdbc.url"));
//        ds.setUsername(env.getProperty("jdbc.username"));
//        ds.setPassword(env.getProperty("jdbc.password"));
//        return ds;
//    }
    /**
     * <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
     *     <property name="locations">
     *         <list>
     *             <value>classpath:foo.properties</value>
     *         </list>
     *     </property>
     *     <property name="ignoreUnresolvablePlaceholders" value="true"/>
     * </bean>
     *
     * ps. If the properties file is defined in XML with <property-placeholder>
     *       If the file is defined in the Parent context:
     *         @Value works in Child context: NO
     *         @Value works in Parent context: YES
     *       If the file is defined in the Child context:
     *         @Value works in Child context: YES
     *         @Value works in Parent context: NO
     *       Finally, <property-placeholder> does not expose the properties to the environment, so:
     *         environment.getProperty works in either context: NO
     *
     * ps. If the properties file is defined in Java with @PropertySource
     *       If the file is defined in the Parent context:
     *         @Value works in Child context: YES
     *         @Value works in Parent context: YES
     *         environment.getProperty in Child context: YES
     *         environment.getProperty in Parent context: YES
     *       If the file is defined in the Child context:
     *         @Value works in Child context: YES
     *         @Value works in Parent context: NO
     *         environment.getProperty in Child context: YES
     *         environment.getProperty in Parent context: NO
     */
    @Bean
    public static PropertyPlaceholderConfigurer properties() {
        PropertyPlaceholderConfigurer ppc
                = new PropertyPlaceholderConfigurer();
        Resource[] resources = new ClassPathResource[] {new ClassPathResource("idv/spring/ioc/ch01xml/jdbc.properties")};
        ppc.setLocations(resources);
        ppc.setIgnoreUnresolvablePlaceholders(true);
        return ppc;
    }


    public static class Engine {
        private String type;

        public Engine(String type) {
            this.type = type;
        }
    }
//    @Component("car")
//    public static class Car {
//        private Engine engine;
//
//        public Car(Engine engine) {
//            this.engine = engine;
//        }
//    }
}






package idv.spring.ioc.ch03javaconfig;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

import java.util.Arrays;
import java.util.List;

/**
 * ==== @Scope ====
 *   == scopeName ==
 *   default is empty string("") which implies SCOPE_SINGLETON.
 *
 * ==== @Lazy ====
 * If this annotation is not present on a @Component or @Bean definition, eager initialization will occur.
 * If present and set to true, the @Bean or @Component will not be initialized until referenced by another bean or explicitly retrieved from the enclosing BeanFactory. If present and set to false, the bean will be instantiated on startup by bean factories that perform eager initialization of singletons.
 *
 * ==== @Profile ====
 *   @Component
 *   @Profile("dev")
 *   public class DevDatasourceConfig
 *
 *   <beans profile="dev">
 *       <bean id="devDatasourceConfig" class="idv.orangec.profiles.DevDatasourceConfig" />
 *   </beans>
 *
 *   == set profiles ==
 *   1. Programmatically via WebApplicationInitializer interface
 *     @Configuration
 *     public class MyWebApplicationInitializer implements WebApplicationInitializer {
 *         @Override
 *         public void onStartup(ServletContext servletContext) throws ServletException {
 *             servletContext.setInitParameter("spring.profiles.active", "dev");
 *         }
 *     }
 *
 *   2. Programmatically via ConfigurableEnvironment
 *     @Autowired
 *     private ConfigurableEnvironment env;
 *     ...
 *     env.setActiveProfiles("dev");
 *
 *   3. Context Parameter in web.xml
 *     <context-param>
 *         <param-name>contextConfigLocation</param-name>
 *         <param-value>/WEB-INF/app-config.xml</param-value>
 *     </context-param>
 *     <context-param>
 *         <param-name>spring.profiles.active</param-name>
 *         <param-value>dev</param-value>
 *     </context-param>
 *
 *   4. JVM System Parameter
 *     -Dspring.profiles.active=dev
 */
@Configuration()
public class BeanConfig {
    @Bean
    @Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
    public EmployeeService employeeService() {
        return new EmployeeService();
    }

    @Bean
    public EmployeeDao employeeDao() {
        return new EmployeeDao();
    }

//    @Bean
//    @Profile("dev")
//    public DataSource getDataSource() {
//        JdbcDataSource dataSource = new JdbcDataSource();
//        dataSource.setURL(jdbcUrl);
//        dataSource.setUser(user);
//        dataSource.setPassword(password);
//        return dataSource;
//    }
//    @Bean
//    @Profile("test")
//    public DataSource dataSource(){
//        return new EmbeddedDatabaseBuilder()
//                .setType(EmbeddedDatabaseType.H2)
//                .addScript("classpath:schema.sql")
//                .addScript("classpath:data.sql")
//                .build();
//    }

    public static class Employee {
        private String name;
        private double salary;

        public Employee(String name, double salary) {
            this.name = name;
            this.salary = salary;
        }

        @Override
        public String toString() {
            return "Employee {name = " + name + ", salary = " + salary + "}";
        }
    }

    public static class EmployeeDao {
        public Employee loadEmp() {
            return new Employee("Tony", 75000);
        }

        public List<Employee> loadEmps() {
            return Arrays.asList(new Employee("Tony", 75000), new Employee("Mei", 40000), new Employee("Nancy", 60000));
        }
    }

    public static class EmployeeService {
        @Autowired
        private EmployeeDao empDao;
    }
}
