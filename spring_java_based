package idv.spring.ioc.ch03javaconfig;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

/**
 * ==== Java-based Container Configuration ====
 * Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework.
 * Thus, you can define beans external to your application classes by using Java rather than XML files.
 * To use these new features, see the @Configuration, @Bean, @Import, and @DependsOn annotations.
 * _Spring 3.0 開始，支援使用 Java class 取代 XML 的方式設定 Spring bean
 *
 * the @Configuration is used to indicates that its primary purpose is as a source of bean definitions.
 * Furthermore, @Configuration classes let inter-bean dependencies be defined by calling other @Bean methods in the same class.
 *
 *   @Configuration
 *   public class ApplicationConfig {
 *   }
 *
 * The @Bean annotation is used to indicate that a method instantiates, configures, and initializes a new object to be managed by the Spring IoC container.
 * For those familiar with Spring’s <beans/> XML configuration, the @Bean annotation plays the same role as the <bean/> element.
 * You can use @Bean-annotated methods with any Spring @Component.
 * However, they are most often used with @Configuration beans.
 *
 * An application may make use of just one @Configuration-annotated class, or many.
 * @Configuration can be considered the equivalent of XML's <beans/> element.
 * Like <beans/>, it provides an opportunity to explicitly set defaults for all enclosed bean definitions.
 * _一個 application 可以有一或多個以 @Configuration 宣告的設定檔 (多個 application context)
 * _@Configuration 相當於 XML 設定檔的 <beans/> 元素
 * _就像 <beans/> 一樣，@Configuration 也有各種預設的值
 *
 *   @Configuration(defaultAutowire = Autowire.BY_TYPE, defaultLazy = Lazy.FALSE)
 *   public class ApplicationConfig {
 *       // bean definitions follow
 *   }
 *
 * ==== Receiving lifecycle callbacks ====
 * Using JSR-250 annotations
 * Spring supports JSR 250 Annotations such as @PostConstruct, @PreDestroy and @Resource annotations.
 *
 * == Using Spring interfaces ==
 * Spring's lifecycle callbacks are fully supported.
 * If a bean implements InitializingBean, DisposableBean, or Lifecycle, their respective methods will be called by the container in accordance with their Javadoc.
 *
 * == Using @Bean initMethodName / destroyMethodName attributes ==
 * The @Bean annotation supports specifying arbitrary initialization and destruction callback methods,
 *   much like Spring XML's init-method and destroy-method attributes to the bean element:
 *
 *   @Bean(initMethod = "init", destroyMethod = "destroy")
 *
 * == Using *Aware interfaces ==
 * The standard set of *Aware interfaces such as BeanFactoryAware, BeanNameAware, MessageSourceAware, ApplicationContextAware, etc. are fully supported.
 */
@Configuration
public class MyJavaBasedApplicationContext {
    private static final Logger LOGGER = LoggerFactory.getLogger(MyJavaBasedApplicationContext.class);

    /**
     * INFO  org.springframework.context.support.AbstractApplicationContext.prepareRefresh(AbstractApplicationContext.java:589) - Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@1b40d5f0: startup date [Tue Apr 16 17:48:38 CST 2019]; root of context hierarchy
     * INFO  org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.<init>(AutowiredAnnotationBeanPostProcessor.java:154) - JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
     * INFO  idv.spring.ioc.ch03javaconfig.MyJavaBasedApplicationContext.main(MyJavaBasedApplicationContext.java:86) - value = MyModel {abc = abc}
     * INFO  org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:989) - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@1b40d5f0: startup date [Tue Apr 16 17:48:38 CST 2019]; root of context hierarchy
     */
    public static void main(String[] args) {
//        ApplicationContext ctx = new AnnotationConfigApplicationContext(MyJavaBasedApplicationContext.class);
//        MyService myService = ctx.getBean(MyService.class);
//        MyModel value = myService.loadMyModel();
//        ((ConfigurableApplicationContext) ctx).close();
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(MyJavaBasedApplicationContext.class);
        ctx.refresh();
        MyService myService = ctx.getBean(MyService.class);
        MyModel value = myService.loadMyModel();
        LOGGER.info("value = " + value);
        ctx.close();
    }

    /**
     * ==== @Bean ====
     * @Bean is a method-level annotation and a direct analog of the XML <bean/> element.
     *
     * The annotation supports most of the attributes offered by <bean/>, such as:
     *   init-method, destroy-method, autowiring, lazy-init, dependency-check, depends-on and scope.
     *
     *   @Bean(
     *       autowire = Autowire.BY_NAME,
     *       name = {"a", "b"},
     *       initMethod = "init",
     *       destroyMethod = "destroy"
     *   )
     *
     * ==== Declaring a bean ====
     * To declare a bean, simply annotate a method with the @Bean annotation.
     * When JavaConfig encounters such a method, it will execute that method and register the return value as a bean within a BeanFactory.
     * By default, the bean name will be the same as the method name (see bean naming for details on how to customize this behavior).
     * _用 @Bean 宣告在 method
     * _當 JavaConfig 執行此被 @Bean 宣告的方法，會將回傳的 bean 註冊在 BeanFactory
     * _如果 @Bean 沒指定名稱，則預設的 bean name 就是 method name
     *
     *   @Configuration
     *   public class AppConfig {
     *       @Bean
     *       public TransferService transferService() {
     *           return new a.b.TransferServiceImpl();
     *       }
     *   }
     *
     * For comparison sake, the configuration above is exactly equivalent to the following Spring XML:
     * _上面的 Java configuration 等同於下面的 XML 宣告方式
     *
     *   <beans>
     *       <bean name="transferService" class="a.b.TransferServiceImpl"/>
     *   </beans>
     *
     * Both will result in a bean named transferService being available in the BeanFactory / ApplicationContext,
     *   bound to an object instance of type TransferServiceImpl: transferService -> a.b.TransferServiceImpl
     * _上面兩種宣告方式，都會在 BeanFactory 或 ApplicationContext 註冊一個名稱為 transferService，型別為 a.b.TransferServiceImpl 的 spring managed bean
     *
     * ==== Injecting dependencies ====
     * When @Beans have dependencies on one another, expressing that dependency is as simple as having one bean method call another:
     * In the example, the foo bean receives a reference to bar via constructor injection.
     * _Java configuration bean 的依賴注入如下 (這個範例是建構子注入)
     *
     *   @Configuration
     *   public class AppConfig {
     *       @Bean
     *       public Foo foo() {
     *           return new Foo(bar());
     *       }
    *
     *       @Bean
     *       public Bar bar() {
     *           return new Bar();
     *       }
     *   }
     */
    @Bean
    public MyService myService() {
        MyService myService = new MyService();
        myService.setMyDao(myDao());
        return myService;
    }

    @Bean
    @Scope(value = BeanDefinition.SCOPE_SINGLETON)
    public MyDao myDao() {
        return new MyDaoImpl();
    }
}

class MyService {
    private MyDao myDao;

    public void setMyDao(MyDao myDao) {
        this.myDao = myDao;
    }

    public MyModel loadMyModel() {
        return myDao.getModel();
    }
}

interface MyDao {
    public MyModel getModel();
}

class MyDaoImpl implements MyDao {
    @Override
    public MyModel getModel() {
        MyModel model = new MyModel();
        model.setAbc("abc");
        return model;
    }
}

class MyModel {
    String abc;

    public String getAbc() {
        return abc;
    }
    public void setAbc(String abc) {
        this.abc = abc;
    }

    @Override
    public String toString() {
        return "MyModel {abc = " + abc + "}";
    }
}
