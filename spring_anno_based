//package idv.spring.ioc.ch02annotation;
//
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.beans.factory.annotation.Qualifier;
//import org.springframework.context.ApplicationContext;
//import org.springframework.context.support.ClassPathXmlApplicationContext;
//
///**
// * ==== Annotation-based configuration ====
// * Spring 2.5 introduced support for annotation-based configuration metadata.
// * Instead of using XML to describe a bean wiring, you can move the bean configuration into the component class itself
// *   by using annotations on the relevant class, method, or field declaration.
// * For example:
// *   Spring 2.0
// *     @Required
// *   Spring 2.5
// *     @Autowired, @Qualifier
// *     @Resource, @PostConstruct, @PreDestroy (JSR-250, javax.annotation)
// *   Spring 3.0
// *     @Primary
// *     @Inject, @Named (JSR-330, javax.inject)
// *   Spring 5.0
// *     @Nullable
// *
// * _Spring 2.5 提供 annotation-based 設定，取代使用 XML 描述 bean 的注入關係
// * _可以使用 @Autowired, @Qualifier, ...以及 JSR-250 annotation 直接設定在 java class
// * _ps. @see idv.spring.ioc.ch01xml.MyXmlApplicationContext 的 autowired(...)
// *      _和 idv/spring/ioc/ch01xml/beansConfig.xml 的 == autowired == 設定
// *
// * == Enabling @Autowired Annotations ==
// * By default, Spring annotation wiring is not turned on in Spring Framework.
// * Therefore, you need to enable it before you can use the Spring annotation-based wiring in the Spring Configuration file.
// *
// *     <context:annotation-config />
// *
// * Once the tag <context:annotation-config /> is configured you have the authority to start annotating your code.
// * It will indicate that the Spring should automatically wire the values into properties methods and constructors.
// * _Spring 預設沒有啟動 annotation wiring 功能，必須在 application context XML 設定檔設定 <context:annotation-config />
// * _Spring 會根據設定在 java class 的 annotation 做 bean 相依的注入
// * _ps. 但是還是需要自己定義各個 bean，只是 bean 之間的相依的 wiring 由 Spring 處理
// *
// * ps. The implicitly registered post-processors include
// *       AutowiredAnnotationBeanPostProcessor,
// *       CommonAnnotationBeanPostProcessor,
// *       PersistenceAnnotationBeanPostProcessor,
// *     and the aforementioned
// *       RequiredAnnotationBeanPostProcessor.
// * _使用 <context:annotation-config /> 會向 Spring container 註冊上述四個 BeanPostProcessor 實做
// *
// * *****************************************************************************
// * <context:annotation-config /> only looks for annotations on beans in the same application context in which it is defined.
// * This means that, if you put <context:annotation-config/> in a WebApplicationContext for a DispatcherServlet,
// *   it only checks for @Autowired beans in your controllers, and not your services.
// * _使用 <context:annotation-config /> 只會查找同一個 application context 使用 annotation 宣告的 bean
// *
// * Annotation injection is performed before XML injection.
// * Thus, the XML configuration overrides the annotations for properties wired through both approaches.
// * _在 XML 和 annotation 有相同 id 的 bean，XML 會覆寫 annotation 的設定
// * *****************************************************************************
// *
// *
// * == @Required ==
// * @see - RequiredAnnotationBeanPostProcessor
// * This annotation indicates that the affected bean property must be populated at configuration time,
// *   through an explicit property value in a bean definition or through autowiring.
// * The container throws an exception if the affected bean property has not been populated.
// * This allows for eager and explicit failure, avoiding NullPointerException instances or the like later on.
// *
// *     == setter injection ==
// *     private FooService fooService;
// *
// *     @Required
// *     public void setFooService(FooService fooService) {
// *         this.fooService = fooService
// *     }
// *
// * The only way to declare your Service final is by using the constructor injection,
// *   which replaces the @Required annotation because it forces the user of your class to instantiate it with the required services.
// * The user does not have to be Spring, it could be a simple unit test as well
// * You should use constructor injection for mandatory dependencies and setter injections for optional dependencies instead of field injection.
// * Some reasons why:
// *   1. It makes it clear to everybody which dependencies are required
// *   2. It makes testing easier
// *   3. You can make your objects immutable
// * _使用 constructor injection 是唯一可以宣告 field 為 final 的方式
// * _對於必要的相依關係，建議使用 constructor injection，對於非必要的相依關係，使用 setter injection
// *
// * ps. The @Required annotation is formally deprecated as of Spring Framework 5.1,
// *     in favor of using constructor injection for required settings
// *     (or a custom implementation of InitializingBean.afterPropertiesSet() along with bean property setter methods).
// *     _Spring 5.1 已 deprecated
// *     _對於必須設值的 field，使用 constructor injection 比較好
// *
// * ps. The required attribute of @Autowired is recommended over the @Required annotation.
// *     The required attribute indicates that the property is not required for autowiring purposes.
// *     _建議使用 @Autowired(required = [true|false]) 的 required 屬性 取代 @Required
// *
// * == @Autowired ==
// * You can apply the @Autowired annotation to fields, setter methods, constructors
// * By default, Spring resolves @Autowired entries by type.
// * If more than one beans of the same type are available in the container,
// *   the framework will throw a fatal exception indicating that more than one bean is available for autowiring.
// * _@@Autowired 可以用在 field, setter, constructor
// * _@Autowired 預設為 by type 做 dependency injection (XML 設定可以 byName, byType, constructor)
// * _若 @Autowired 註解的類別有超過一個以上的 bean，Spring 會拋出 NoUniqueBeanDefinitionException
// *
// *     == field injection ==
// *     @Autowired
// *     private FooService fooService;
// *
// *     == setter injection ==
// *     private FooService fooService;
// *
// *     @Autowired
// *     public void setFooService(FooService fooService) {
// *         this.fooService = fooService
// *     }
// *
// *     == constructor injection ==
// *     private final FooService fooService;
// *
// *     @Autowired
// *     public MyComponent(FooService fooService) {
// *         this.fooService = fooService;
// *     }
// *
// *     == @Autowired and Optional Dependencies ==
// *     @Autowired(required = false)
// *     private FooService fooService;
// *
// *     org.springframework.beans.factory.NoSuchBeanDefinitionException:
// *       No qualifying bean of type [idv.orangec.FooService] found for dependency:
// *         expected at least 1 bean which qualifies as autowire candidate for this dependency.
// *     _避免 Spring context 找不到對應的 bean 做 wiring，設定 @Autowired(required = false)
// *
// * *****************************************************************************
// * The @Autowired, @Inject, @Value, and @Resource annotations are handled by Spring BeanPostProcessor implementations.
// * This means that you cannot apply these annotations within your own BeanPostProcessor or BeanFactoryPostProcessor types (if any).
// * These types must be 'wired up' explicitly by using XML or a Spring @Bean method.
// * *****************************************************************************
// *
// * By default, Spring resolves @Autowired entries by type.
// * If more than one beans of the same type are available in the container, the framework will throw a fatal exception indicating that more than one bean is available for autowiring.
// * _@Autowired 預設為 by type 做 dependency injection
// *
// * _ps. @Autowired 實做為 AutowiredAnnotationBeanPostProcessor
// *      _該類別實做 MergedBeanDefinitionPostProcessor
// *      _Spring 的 application context 啟動後會執行 AbstractApplicationContext 的 refresh()
// *      _refresh() 會呼叫 registerBeanPostProcessors(beanFactory) 完成對 AutowiredAnnotationBeanPostProcessor 的註冊
// *      _refresh() 會呼叫 finishBeanFactoryInitialization(beanFactory) 對非延遲 singleton bean 進行初始化
// *
// * ps. JSR 330’s @Inject annotation can be used in place of Spring’s @Autowired annotation
// *     _@Inject 可以取代 @Autowired
// *
// * ==== @Qualifier ====
// * Because autowiring by type may lead to multiple candidates, it is often necessary to have more control over the selection process.
// * One way to accomplish this is with Spring’s @Qualifier annotation.
// * This annotation is used to avoid conflicts in bean mapping and we need to provide the bean name that will be used for autowiring.
// * _@Qualifier 常常會搭配 @Autowired 使用
// * _可以避免 @Autowired 做 dependency injection 時， 發生 NoUniqueBeanDefinitionException
// *
// *   @Autowired              -> by type
// *   @Autowired + @Qualifier -> by name
// *
// *
// * == @Resource ==
// * Spring also supports injection by using the JSR-250 @Resource annotation (javax.annotation.Resource) on fields or bean property setter methods.
// * This is a common pattern in Java EE: for example, in JSF-managed beans and JAX-WS endpoints.
// * Spring supports this pattern for Spring-managed objects as well.
// *
// * Resource annotation takes a name attribute.
// * By default, Spring interprets that value as the bean name to be injected.
// * If no name is explicitly specified, the default name is derived from the field name or setter method.
// * In case of a field, it takes the field name.
// * In case of a setter method, it takes the bean property name.
// *
// * _使用 @Resource 而沒使定 name 屬性時
// *   @Resource
// *   private ABC abc;
// *   -> it is equivalent to @Resource(name = "abc")
// *
// *   @Resource
// *   public void setAbc(ABC xyz) {
// *      abc = xyz;
// *   }
// *   -> it is equivalent to @Resource(name = "xyz")
// *
// *
// * == @Inject ==
// * _使用 @Inject 必須先 include jar
// *   <dependency>
// *       <groupId>javax.inject</groupId>
// *       <artifactId>javax.inject</artifactId>
// *       <version>1</version>
// *   </dependency>
// *
// * The @Inject annotation belongs to the JSR-330 annotations collection.
// * This annotation has the following execution paths, listed by precedence
// *   1. Match by Type
// *      Unlike the @Resource annotation, which resolves dependencies by name first;
// *        the default behavior of the @Inject annotation resolves dependencies by type.
// *
// *        @Inject
// *        private Foo foo;
// *
// *   2. Match by Qualifier
// *
// *        @Inject
// *        @Qualifier("firstFoo")
// *        private Foo foo;
// *
// *   3. Match by Name
// *
// *        @Inject
// *        @Named("firstFoo")
// *        private Foo foo;
// *
// *
// * == @Primary ==
// * Because autowiring by type may lead to multiple candidates, it is often necessary to have more control over the selection process.
// * One way to accomplish this is with Spring’s @Primary annotation.
// * @Primary indicates that a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency.
// * If exactly one primary bean exists among the candidates, it becomes the autowired value.
// * _使用 by type 的 autowiring 可能遇到多個符合的 bean (org.springframework.beans.factory.NoUniqueBeanDefinitionException)
// *
// *     @Component("foo1")
// *     @Primary
// *     public class Foo {
// *     }
// *
// *     @Component("foo2")
// *     public class Foo {
// *     }
// *
// *     @Service
// *     public class FooService {
// *         @Autowired
// *         private Foo foo;
// *     }
// *
// * In some cases, we need to register more than one bean of the same type.
// * Spring throws NoUniqueBeanDefinitionException if we try to run the application.
// *
// *     @Configuration
// *     public class FooConfiguration {
// *         @Bean
// *         @Primary
// *         public idv.orangec.Foo firstFoo() { ... }
// *
// *         @Bean
// *         public idv.orangec.Foo secondFoo() { ... }
// *     }
// *
// *     <beans ...>
// *         <bean class="idv.orangec.Foo" primary="true"></bean>
// *
// *         <bean class="idv.orangec.Foo"></bean>
// *     </beans>
// *
// * To access beans with the same type we usually use @Qualifier("beanName") annotation.
// * We apply it at the injection point along with @Autowired.
// * In our case, we select the beans at the configuration phase so @Qualifier can’t be applied here.
// * To resolve this issue Spring offers the @Primary annotation.
// */
//public class MyAnnotationBasedApplicationContext {
//
//    private static final Logger LOGGER = LoggerFactory.getLogger(MyAnnotationBasedApplicationContext.class);
//
//    @Autowired
//    @Qualifier("firstFoo")
//    private Foo foo;
//
////    @Resource(name = "firstFoo")
////    private Foo foo;
//
//    public static class Foo {
//        private String bar;
//
//        public Foo(String bar) {
//            this.bar = bar;
//        }
//
//        public String getBar() {
//            return bar;
//        }
//    }
//
//    public static void main(String[] args) {
//        new MyAnnotationBasedApplicationContext().testInjectByAutowired();
//    }
//
//    /**
//     * 1. AutowiredAnnotationBeanPostProcessor
//     * <beans ...>
//     *     <bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor" />
//     *
//     *     <bean id="firstFoo" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo">
//     *         <constructor-arg name="bar" value="1st foo" />
//     *     </bean>
//     *
//     *     <bean id="myAnnoCtx" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext" />
//     * </beans>
//     *
//     * @Autowired
//     * private Foo foo;
//     * -------------------------------------------------------------------------
//     * org.springframework.context.support.AbstractApplicationContext.prepareRefresh(AbstractApplicationContext.java:589) - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@19bb089b: startup date [Mon May 20 15:31:56 CST 2019]; root of context hierarchy
//     * org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:316) - Loading XML bean definitions from class path resource [idv/spring/ioc/ch02annotation/applicationContext.xml]
//     * org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.<init>(AutowiredAnnotationBeanPostProcessor.java:154) - JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:317) - bean name: org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#0
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:317) - bean name: firstFoo
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:317) - bean name: myAnnoCtx
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:320) - foo.getBar() = 1st foo
//     * org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:989) - Closing org.springframework.context.support.ClassPathXmlApplicationContext@19bb089b: startup date [Mon May 20 15:31:56 CST 2019]; root of context hierarchy
//     *
//     * ps. 使用 AutowiredAnnotationBeanPostProcessor，沒有支援 @Qualifier
//     *     若有多個符合 type 的 bean，則會發生 NoUniqueBeanDefinitionException
//     *     直接使用 <context:annotation-config /> 就好
//     *
//     *
//     * 2. <context:annotation-config />
//     * <beans ...>
//     *     <context:annotation-config />
//     *
//     *     <bean id="firstFoo" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo">
//     *         <constructor-arg name="bar" value="1st foo" />
//     *     </bean>
//     *
//     *     <bean id="myAnnoCtx" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext" />
//     * </beans>
//     *
//     * @Autowired
//     * private Foo foo;
//     * -------------------------------------------------------------------------
//     * org.springframework.context.support.AbstractApplicationContext.prepareRefresh(AbstractApplicationContext.java:589) - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@19bb089b: startup date [Mon May 20 15:34:08 CST 2019]; root of context hierarchy
//     * org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:316) - Loading XML bean definitions from class path resource [idv/spring/ioc/ch02annotation/applicationContext.xml]
//     * org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.<init>(AutowiredAnnotationBeanPostProcessor.java:154) - JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:339) - bean name: org.springframework.context.annotation.internalConfigurationAnnotationProcessor
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:339) - bean name: org.springframework.context.annotation.internalAutowiredAnnotationProcessor
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:339) - bean name: org.springframework.context.annotation.internalRequiredAnnotationProcessor
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:339) - bean name: org.springframework.context.annotation.internalCommonAnnotationProcessor
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:339) - bean name: org.springframework.context.event.internalEventListenerProcessor
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:339) - bean name: org.springframework.context.event.internalEventListenerFactory
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:339) - bean name: firstFoo
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:339) - bean name: myAnnoCtx
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByAutowired(MyAnnotationBasedApplicationContext.java:342) - foo.getBar() = 1st foo
//     * org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:989) - Closing org.springframework.context.support.ClassPathXmlApplicationContext@19bb089b: startup date [Mon May 20 15:34:08 CST 2019]; root of context hierarchy
//     *
//     * ps. 使用 <context:annotation-config /> 可以看到，Spring context 多了
//     *     ConfigurationAnnotationProcessor, RequiredAnnotationProcessor, CommonAnnotationProcessor, ...
//     */
//    private void testInjectByAutowired() {
//        ApplicationContext ctx = new ClassPathXmlApplicationContext("idv/spring/ioc/ch02annotation/applicationContext.xml");
////        ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:idv/spring/ioc/ch02annotation/applicationContext.xml");
//        for (String name : ctx.getBeanDefinitionNames()) {
//            LOGGER.info("bean name: " + name);
//        }
//        MyAnnotationBasedApplicationContext myAnnoCtx = ctx.getBean("myAnnoCtx", MyAnnotationBasedApplicationContext.class);
//        LOGGER.info("foo.getBar() = " + myAnnoCtx.foo.getBar());
//        ((ClassPathXmlApplicationContext) ctx).close();
//    }
//
//    /**
//     * <beans ...>
//     *     <context:annotation-config />
//     *
//     *     <bean id="firstFoo" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo">
//     *         <constructor-arg name="bar" value="1st foo" />
//     *     </bean>
//     *     <bean id="secondFoo" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo">
//     *         <constructor-arg name="bar" value="2nd foo" />
//     *     </bean>
//     *
//     *     <bean id="myAnnoCtx" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext" />
//     * </beans>
//     *
//     * @Autowired
//     * private Foo foo;
//     * -------------------------------------------------------------------------
//     * Exception in thread "main" org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext#0': Unsatisfied dependency expressed through field 'foo'; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo' available: expected single matching bean but found 2: firstFoo,secondFoo
//     * 	 at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:587)
//     * 	 at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:91)
//     * 	 at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:373)
//     * 	 ...
//     * 	 at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:85)
//     * 	 at idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testXmlAutowired2(MyAnnotationBasedApplicationContext.java:301)
//     * 	 at idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.main(MyAnnotationBasedApplicationContext.java:235)
//     * Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo' available: expected single matching bean but found 2: firstFoo,secondFoo
//     */
////    private void testXmlAutowired2() {
////        ApplicationContext ctx = new ClassPathXmlApplicationContext("idv/spring/ioc/ch02annotation/applicationContext.xml");
//////        ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:idv/spring/ioc/ch02annotation/applicationContext.xml");
////        ((ClassPathXmlApplicationContext) ctx).close();
////    }
//
//    /**
//     * <beans ...>
//     *     <context:annotation-config />
//     *
//     *     <bean id="firstFoo" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo">
//     *         <constructor-arg name="bar" value="1st foo" />
//     *     </bean>
//     *     <bean id="secondFoo" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo">
//     *         <constructor-arg name="bar" value="2nd foo" />
//     *     </bean>
//     *
//     *     <bean id="myAnnoCtx" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext" />
//     * </beans>
//     *
//     * @Autowired
//     * @Qualifier("firstFoo")
//     * private Foo foo;
//     * ----------------------
//     * bar = 1st foo
//     */
//    private void testInjectByAutowiredQualifier() {
//        ApplicationContext ctx = new ClassPathXmlApplicationContext("idv/spring/ioc/ch02annotation/applicationContext.xml");
////        ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:idv/spring/ioc/ch02annotation/applicationContext.xml");
//        Foo foo = ctx.getBean("firstFoo", Foo.class);
//        LOGGER.info("bar = " + foo.bar);
//        ((ClassPathXmlApplicationContext) ctx).close();
//    }
//
//    /**
//     * <context:annotation-config />
//     *
//     * <bean id="firstFoo" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo">
//     *     <constructor-arg name="bar" value="1st foo" />
//     * </bean>
//     * <bean id="secondFoo" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo">
//     *     <constructor-arg name="bar" value="2nd foo" />
//     * </bean>
//     *
//     * <bean id="myAnnoCtx" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext" />
//     *
//     * @Resource(name = "firstFoo")
//     * private Foo foo;
//     * -------------------------------------------------------------------------
//     * org.springframework.context.support.AbstractApplicationContext.prepareRefresh(AbstractApplicationContext.java:589) - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@19bb089b: startup date [Mon May 20 15:24:28 CST 2019]; root of context hierarchy
//     * org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:316) - Loading XML bean definitions from class path resource [idv/spring/ioc/ch02annotation/applicationContext.xml]
//     * org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.<init>(AutowiredAnnotationBeanPostProcessor.java:154) - JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByResource(MyAnnotationBasedApplicationContext.java:410) - bean name: org.springframework.context.annotation.internalConfigurationAnnotationProcessor
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByResource(MyAnnotationBasedApplicationContext.java:410) - bean name: org.springframework.context.annotation.internalAutowiredAnnotationProcessor
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByResource(MyAnnotationBasedApplicationContext.java:410) - bean name: org.springframework.context.annotation.internalRequiredAnnotationProcessor
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByResource(MyAnnotationBasedApplicationContext.java:410) - bean name: org.springframework.context.annotation.internalCommonAnnotationProcessor
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByResource(MyAnnotationBasedApplicationContext.java:410) - bean name: org.springframework.context.event.internalEventListenerProcessor
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByResource(MyAnnotationBasedApplicationContext.java:410) - bean name: org.springframework.context.event.internalEventListenerFactory
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByResource(MyAnnotationBasedApplicationContext.java:410) - bean name: firstFoo
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByResource(MyAnnotationBasedApplicationContext.java:410) - bean name: secondFoo
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByResource(MyAnnotationBasedApplicationContext.java:410) - bean name: myAnnoCtx
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext.testInjectByResource(MyAnnotationBasedApplicationContext.java:413) - foo.getBar() = 1st foo
//     */
//    private void testInjectByResource() {
//        ApplicationContext ctx = new ClassPathXmlApplicationContext("idv/spring/ioc/ch02annotation/applicationContext.xml");
////        ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:idv/spring/ioc/ch02annotation/applicationContext.xml");
//        for (String name : ctx.getBeanDefinitionNames()) {
//            LOGGER.info("bean name: " + name);
//        }
//        MyAnnotationBasedApplicationContext myAnnoCtx = ctx.getBean("myAnnoCtx", MyAnnotationBasedApplicationContext.class);
//        LOGGER.info("foo.getBar() = " + myAnnoCtx.foo.getBar());
//        ((ClassPathXmlApplicationContext) ctx).close();
//    }
//
//}

== applicationContext.xml ==
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <!-- for @Required (Deprecated from Spring 5.1)-->
    <!--<bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" />-->

    <!-- for @Autowired -->
    <!--<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor" />-->

    <!-- for @ Resource, @PostConstruct, @PreDestroy -->
    <!--<bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>-->

    <!-- for @PersistenceContext (for injection of the corresponding JPA resources EntityManagerFactory and EntityManager) -->
    <!--<bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor" />-->

    <!--
    The implicitly registered post-processors include:
        AutowiredAnnotationBeanPostProcessor,
        CommonAnnotationBeanPostProcessor,
        PersistenceAnnotationBeanPostProcessor,
        RequiredAnnotationBeanPostProcessor.

    _使用 <context:annotation-config /> 會對 Spring container 註冊上面四個 BeanPostProcessor
    -->
    <context:annotation-config />

    <bean id="firstFoo" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo">
        <constructor-arg name="bar" value="1st foo" />
    </bean>
    <bean id="secondFoo" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext$Foo">
        <constructor-arg name="bar" value="2nd foo" />
    </bean>

    <bean id="myAnnoCtx" class="idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext" />
</beans>





//package idv.spring.ioc.ch02annotation;
//
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.context.ApplicationContext;
//import org.springframework.context.support.ClassPathXmlApplicationContext;
//import org.springframework.stereotype.Component;
//import org.springframework.stereotype.Repository;
//import org.springframework.stereotype.Service;
//
//import java.util.Arrays;
//import java.util.List;
//
///**
// * ==== Automatically Detecting Classes and Registering Bean Definitions ====
// * Spring 2.5 introduced support for annotation-based configuration metadata.
// * Instead of using XML to describe a bean wiring, you can move the bean configuration into the component class itself by using annotations on the relevant class, method, or field declaration.
// * _Spring 2.5 提供 @Autowired 機制，由 Spring container 負責注入 bean 與 bean 之間的相依關係
// * _但是每個 bean 還是需要個別設定在 XML 裡
// * 
// *
// * Spring provides further stereotype annotations: @Component, @Service, and @Controller.
// * @Component is a generic stereotype for any Spring-managed component.
// * @Repository, @Service, and @Controller are specializations of @Component for more specific use cases,
// *   for example, in the persistence, service, and presentation layers, respectively.
// * Therefore, you can annotate your component classes with @Component, but by annotating them with @Repository, @Service, or @Controller instead,
// *   your classes are more properly suited for processing by tools or associating with aspects.
// *
// *   @Component     generic stereotype for any Spring-managed component
// *   @Repository    stereotype for persistence layer
// *   @Service       stereotype for service layer
// *   @Controller    stereotype for presentation layer (spring-mvc)
// *
// * ==== Using Filters to Customize Scanning ====
// * @see \main\resources\idv\spring\ioc\ch02annotation\applicationContext2.xml
// *      <context:include-filter />, <context:exclude-filter />
// */
//@Component("myAnnoCtx")
//public class MyAnnotationBasedApplicationContext2 {
//
//    private static final Logger LOGGER = LoggerFactory.getLogger(MyAnnotationBasedApplicationContext2.class);
//
//    @Autowired
//    private FooService fooService;
//
//    @Service("fooService")
//    public static class FooService {
//
//        @Autowired
//        private FooDao fooDao;
//
//        public Foo getFoo() {
//            return fooDao.getFoo();
//        }
//
//        public List<Foo> getFooList() {
//            return fooDao.getFooList();
//        }
//    }
//
//    @Repository("fooDao")
//    public static class FooDao {
//        public Foo getFoo() {
//            return new Foo("abc");
//        }
//
//        public List<Foo> getFooList() {
//            return Arrays.asList(new Foo("abc"), new Foo("xyz"));
//        }
//    }
//
//    public static class Foo {
//        private String bar;
//
//        public Foo(String bar) {
//            this.bar = bar;
//        }
//
//        @Override
//        public String toString() {
//            return "Foo {bar = " + bar + "}";
//        }
//    }
//
//    public static void main(String[] args) {
//        new MyAnnotationBasedApplicationContext2().testComponentScan();
//    }
//
//    /**
//     * org.springframework.context.support.AbstractApplicationContext.prepareRefresh(AbstractApplicationContext.java:589) - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@19bb089b: startup date [Mon May 20 16:47:14 CST 2019]; root of context hierarchy
//     * org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:316) - Loading XML bean definitions from class path resource [idv/spring/ioc/ch02annotation/applicationContext2.xml]
//     * org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.<init>(AutowiredAnnotationBeanPostProcessor.java:154) - JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
//     * idv.spring.ioc.ch02annotation.MyAnnotationBasedApplicationContext2.testComponentScan(MyAnnotationBasedApplicationContext2.java:113) - foo = Foo {bar = abc}
//     * org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:989) - Closing org.springframework.context.support.ClassPathXmlApplicationContext@19bb089b: startup date [Mon May 20 16:47:14 CST 2019]; root of context hierarchy
//     */
//    public void testComponentScan() {
//        ApplicationContext ctx = new ClassPathXmlApplicationContext("idv/spring/ioc/ch02annotation/applicationContext2.xml");
////        ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:idv/spring/ioc/ch02annotation/applicationContext2.xml");
//        MyAnnotationBasedApplicationContext2 myAnnoCtx = ctx.getBean("myAnnoCtx", MyAnnotationBasedApplicationContext2.class);
//
//        Foo foo = myAnnoCtx.fooService.getFoo();
//        LOGGER.info("foo = " + foo);
//
//        ((ClassPathXmlApplicationContext) ctx).close();
//    }
//
//}

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <!--<context:annotation-config />-->

    <!--
    The use of <context:component-scan> implicitly enables the functionality of <context:annotation-config>.
    There is usually no need to include the <context:annotation-config> element when using <context:component-scan>
    _<context:component-scan> 會啟動 <context:annotation-config>，所以不必再設定 <context:annotation-config />

    Filter Type          Example Expression            Description
    ============================================================================
    annotation(default)  org.example.SomeAnnotation    An annotation to be present at the type level in target components.
    assignable           org.example.SomeClass         A class (or interface) that the target components are assignable to (extend or implement).
    aspectj              org.example..*Service+        An AspectJ type expression to be matched by the target components.
    regex                org\.example\.Default.*       A regex expression to be matched by the target components class names.
    custom               org.example.MyTypeFilter      A custom implementation of the org.springframework.core.type.TypeFilter interface.

        <context:component-scan base-package="idv.spring.ioc">
            <context:include-filter type="regex" expression=".*Stub.*Repository" />
            <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository" />
        </context:component-scan>
    -->
    <context:component-scan base-package="idv.spring.ioc.ch02annotation">
        <!--<context:include-filter type="" expression="" />-->
        <!--<context:exclude-filter type="" expression="" />-->
    </context:component-scan>

</beans>


== applicationContext.xml ==
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <!--<context:annotation-config />-->

    <!--
    The use of <context:component-scan> implicitly enables the functionality of <context:annotation-config>.
    There is usually no need to include the <context:annotation-config> element when using <context:component-scan>
    _<context:component-scan> 會啟動 <context:annotation-config>，所以不必再設定 <context:annotation-config />

    Filter Type          Example Expression            Description
    ============================================================================
    annotation(default)  org.example.SomeAnnotation    An annotation to be present at the type level in target components.
    assignable           org.example.SomeClass         A class (or interface) that the target components are assignable to (extend or implement).
    aspectj              org.example..*Service+        An AspectJ type expression to be matched by the target components.
    regex                org\.example\.Default.*       A regex expression to be matched by the target components class names.
    custom               org.example.MyTypeFilter      A custom implementation of the org.springframework.core.type.TypeFilter interface.

        <context:component-scan base-package="idv.spring.ioc">
            <context:include-filter type="regex" expression=".*Stub.*Repository" />
            <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository" />
        </context:component-scan>
    -->
    <context:component-scan base-package="idv.spring.ioc.ch02annotation">
        <!--<context:include-filter type="" expression="" />-->
        <!--<context:exclude-filter type="" expression="" />-->
    </context:component-scan>

</beans>









//package idv.javaee.servlet.servlet.webxml;
//
//import java.io.*;
//import java.nio.file.Files;
//import java.nio.file.Path;
//
//import javax.servlet.ServletException;
//import javax.servlet.http.HttpServlet;
//import javax.servlet.http.HttpServletRequest;
//import javax.servlet.http.HttpServletResponse;
//import javax.servlet.http.Part;
//
///**
// * <servlet>
// *     <servlet-name>fileUploadServlet</servlet-name>
// *     <servlet-class>idv.javaee.servlet.servlet.UploadDownloadServlet</servlet-class>
// *     <multipart-config>
// *         <location>/tmp</location>
// *         <max-file-size>20848820</max-file-size>
// *         <max-request-size>418018841</max-request-size>
// *         <file-size-threshold>1048576</file-size-threshold>
// *     </multipart-config>
// *     <load-on-startup>10</load-on-startup>
// * </servlet>
// *
// *
// * client JSP -> pages/javaee/servlet/servlet/webxml/fileUpload.jsp
// */
//public class UploadDownloadServlet extends HttpServlet {
//    private static final long serialVersionUID = 1L;
//
//    public UploadDownloadServlet() {
//        super();
//    }
//
////  protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
////  }
//
//    @Override
//    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
//        Part filePart = req.getPart("file");
//        if (filePart == null || filePart.getSize() == 0) {
//            res.getWriter().print("No file is uploaded");
//            res.flushBuffer();
//            return;
//        }
//        InputStream inputStream = filePart.getInputStream();
//        String fileName = filePart.getSubmittedFileName();
//
//        System.out.println(System.getProperty("user.dir"));
//        File targetPath = new File("download");
//        if (!targetPath.exists()) {
//            targetPath.mkdirs();
//        }
////        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(new File(File.separator + "download", fileName)));
//        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(new File(targetPath, fileName)));
//
//        int read = 0;
//        final byte[] buffer = new byte[1024];
//        while ((read = inputStream.read(buffer)) != -1) {
//            outputStream.write(buffer, 0, read);
//        }
//        outputStream.close();
//        res.getWriter().print("file had been uploaded");
//    }
//
//
//    private void outputFile(HttpServletResponse res, File file) throws IOException {
//        Path path = file.toPath();
//        String mimeType = Files.probeContentType(path);
//        res.setContentType(mimeType);
////        res.setHeader("Content-disposition", "attachment; filename=\"" + file.getName() + "\"");
//
//        FileInputStream in = null;
//        OutputStream out = null;
//        try {
//            in = new FileInputStream(file);
//            out = res.getOutputStream();
//
//            byte[] buffer = new byte[4096];
//            int length;
//            while ((length = in.read(buffer)) > 0){
//                out.write(buffer, 0, length);
//            }
//            in.close();
//            out.flush();
//        } catch (IOException ex) {
////            LOGGER.error(ex.getMessage(), ex);
//            throw ex;
//        }
//    }
//
//}

== web.xml ==
<!-- file upload -->
<servlet>
<servlet-name>fileUploadServlet</servlet-name>
<servlet-class>idv.javaee.servlet.servlet.webxml.UploadDownloadServlet</servlet-class>
<load-on-startup>10</load-on-startup>
<multipart-config>
<location>/tmp</location>
<max-file-size>20848820</max-file-size>
<max-request-size>418018841</max-request-size>
<file-size-threshold>1048576</file-size-threshold>
</multipart-config>
</servlet>
<servlet-mapping>
<servlet-name>fileUploadServlet</servlet-name>
<url-pattern>/fileUpload.do</url-pattern>
</servlet-mapping>
















//package idv.javaee.servlet.servlet.webxml;
//
//import java.io.IOException;
//import javax.servlet.ServletException;
//import javax.servlet.http.Cookie;
//import javax.servlet.http.HttpServlet;
//import javax.servlet.http.HttpServletRequest;
//import javax.servlet.http.HttpServletResponse;
//
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
//
///**
// * ==== Servlet Container ====
// * 1. Container 的功能
// *   a. 溝通支援: Container 會和 Web Server 溝通，Container 會知道它和 Web Server 的通訊協定，建立 ServerSocket，偵聽通訊埠，建立串流...
// *   b. 生命週期管理: Container 控制 Servlet 的生與死，負責載入類別，實例化 Servlet 物件，初始化 Servlet，呼叫 Servlet 的方法，並且適時的讓 Servlet 物件能夠被 garbage collection
// *   c. 多執行緒支援: Container 接收到一個請求，會自動建立一個 Java 執行緒來處理它，當 Servlet 執行完 service() 方法，該執行緒就會結束 (不過 Servlet 的程式還是要注意執行緒安全)
// *   d. 宣告式的權限管理: 可以透過 XML 格式的部署描述檔(DD，即 web.xml.txt)來組態或修改權限管理機制，而不用寫在 Servlet 中 (Servlet 3.0 開始可以透過 annotation)
// *   e. 支援 JSP: Container 會負責把 JSP 轉譯為 Java 程式(Servlet)
// *
// * 2. Container & Servlet
// *   a. Servlet 本身並沒有 main() method, 它們是由另個稱為 container 的 Java 應用程式所控制
// *   b. 當 web server 接收到一個針對 Servlet 的 request 時，會把這個請求交給該 Servlet 所屬的 Container, Container 建立 HttpServletRequest 以及 HttpServletResponse 物件後,
// *      再交由 Servlet 處理這個請求  (Container 會呼叫 Servlet 的 service()，service() 會判斷要呼叫 doGet() 或  doPost()...)
// *
// * ==== Servlet ====
// * 1. Servlet<interface> ← GenericServlet<interface> ← HttpServlet<abstract class>
// * 2. web application 99% 都是繼承 HttpServlet，然後覆寫 doGet() 或 doPost()
// * 3. lifecycle
// *   a. init()
// *      Container 會在 Servlet 物件被建立後，呼叫 init()，將這個物件初始化為可提供服務的 Servlet
// *   b. service()
// *      當第一個 client request 被 container 接受到後，Container 啟動一個新的執行緒，再透過它呼叫 Servlet 的 service() ( service() 會再根據 HTTP method，呼叫對應的 doGet(), doPost()... )
// *   c. doGet() & doPost()
// *      應用程式的起點，至少要覆寫一個，如果沒覆寫 doGet() 表示不支援 HTTP GET；如果沒覆寫 doPost() 表示不支援 HTTP POST
// *
// * ==== ServletContext ====
// * 1. 每個 web application 只有一個 ServletContext(application context)
// * 2. 可以取得伺服器的資訊，例如 Container 的資料
// *
// * ==== ServletConfig ====
// * 1. 每個 Servlet 都有一個 ServletConfig 物件
// * 2. 可以透過 ServletConfig 存取 ServletContext
// * 3. 可以在 DD(Deployment Descriptor 即 web.xml) 設定 ServletConfig parameter
// */
//public class HelloServlet extends HttpServlet {
//    private static final long serialVersionUID = 1L;
//
//    private static final Logger LOGGER = LoggerFactory.getLogger(HelloServlet.class);
//
//    public HelloServlet() {
//        super();
//    }
//
//    @Override
//    public void init() throws ServletException {
//        LOGGER.info("Servlet " + this.getServletName() + " has started.");
//    }
//
//    @Override
//    public void destroy() {
//        LOGGER.info("Servlet " + this.getServletName() + " has stopped.");
//    }
//
//    /**
//     * 如果沒 override doGet()，則 request 是 HTTP GET 時，會發生 HTTP Error 405 Method Not Allowed
//     *
//     * ==== Using HttpServletRequest ====
//     * 1. Getting Request Parameters
//     *     GET /hello?user=daniel HTTP/1.1
//     *   -> request.getParameter("user");
//     *
//     * 2. Determining Information about the Request Content
//     * Several methods are available to help determine the type, length, and encoding of the content of the HTTP request.
//     * The getContentType() method returns the MIME content type of the request, such as
//     *   application/x-www-form-urlencoded, application/json, text/plain, or application/zip, to name a few.
//     * The getContentLength() and getContentLengthLong() methods both return the number of bytes in the request body (the content length),
//     *   with the latter method being useful for requests whose content might exceed 2 gigabytes (unusual, but not impossible).
//     * The getCharacterEncoding() method returns the character encoding (such as UTF-8 or ISO-8859-1) of the request contents whenever the request contains character-type content.
//     * (text/plain, application/json, and application/ x-www-form-urlencoded are some examples of character-type MIME content types.)
//     * _可以從 HttpServletRequest 取得 MIME(Multipurpose Internet Mail Extensions) type，MIME 就是 Multipurpose Internet Mail Extensions(text/html...)
//     *
//     * 3. Reading the Contents of a Request
//     * The methods getInputStream(), which returns a javax.servlet.ServletInputStream, and getReader(),
//     *   which returns a java.io.BufferedReader, can both be used to read the contents of the request.
//     * You should never use them both on the same request.
//     * After a call to either method, a call to the other will fail with an IllegalStateException.
//     * _getInputStream() 可以讀取 binary data
//     * _getReader() 則是方便處理 character-encoded data
//     * _不可以同時使用這兩個方法，否則會發生 IllegalStateException
//     *
//     * 4. Getting Request Characteristics Such as URL, URI, and Headers
//     *   == getRequestURL() ==
//     *   Returns the entire URL that the client used to make the request, including protocol (http or https), server name, port number, and server path but not including the query string.
//     *
//     *       ex: http://www.example.org/application/index.jsp.
//     *
//     *   == getRequestURI() ==
//     *   This is slightly different from getRequestURL() in that it returns only the server path part of the URL;
//     *
//     *       ex: /application/index.jsp
//     *
//     *   == getServletPath() ==
//     *   Similar to getRequestURI, this returns even less of the URL.
//     *   If the request is /hello-world/greeting?foo=world, the application is deployed as /hello-world on Tomcat, and the servlet-mappings are /greeting, /salutation, and /wazzup,
//     *     getServletPath returns only the part of the URL used to match the servlet mapping: /greeting.
//     *
//     *   == getHeader() ==
//     *   Returns the value of a header with the given name.
//     *   The case of the header does not have to match the case of the string passed into the method, so getHeader("content-type") can match the Content-Type header.
//     *   If there are multiple headers with the same name, this returns only the first value.
//     *   In such cases, you would want to use the getHeaders method to return an enumeration of all the values.
//     *
//     *   == Sessions ==
//     *   getSession()
//     *
//     *   == Cookies ==
//     *   getCookies()
//     *
//     * ==== Using HttpServletResponse ====
//     * 1. Writing to the Response Body
//     * The most common thing you’ll do with a response object, and something you have already done with a response object, is write content to the response body.
//     * This might be HTML to display in a browser, an image that the browser is retrieving, or the contents of a file that the client is downloading.
//     * It could be plain text or binary data.
//     * It might be just a few bytes long or it could be gigabytes long.
//     *
//     * The getOutputStream() method, which returns a javax.servlet.ServletOutputStream, and the getWriter() method,
//     *   which returns a java.io.PrintWriter, both enable you to write data to the response.
//     * Also, you should never use both getOutputStream() and getWriter() in the same response.
//     * After a call to one, a call to the other will fail with an IllegalStateException.
//     * _同樣不能在同一個 response 呼叫 getOutputStream() 和 getWriter()，否則會發生 IllegalStateException
//     *
//     * 2. Setting Headers and Other Response Properties
//     *   == setStatus() ==
//     *   To set the HTTP response status code
//     *
//     *   == getStatus() ==
//     *   To determine what the current status of the response is
//     *
//     *   == sendError() ==
//     *   To set the status code, indicate an optional error message to write to the response data,
//     *     direct the web container to provide an error page to the client, and clear the buffer
//     *
//     *   == sendRedirect() ==
//     *   To redirect the client to a different URL
//     *
//     * ==== example ====
//     * http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=S%3F+ID?p+1=c+d&p+2=e+f#a
//     *
//     * Method                     URL-Decoded    Result
//     * -------------------------------------------------------------------------
//     * getContextPath()           no             /app
//     * getLocalAddr()                            127.0.0.1
//     * getLocalName()                            30thh.loc
//     * getLocalPort()                            8480
//     * getMethod()                               GET
//     * getPathInfo()              yes            /a?+b
//     * getProtocol()                             HTTP/1.1
//     * getQueryString()           no             p+1=c+d&p+2=e+f
//     * getRequestedSessionId()    no             S%3F+ID
//     * getRequestURI()            no             /app/test%3F/a%3F+b;jsessionid=S+ID
//     * getRequestURL()            no             http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=S+ID
//     * getScheme()                               http
//     * getServerName()                           30thh.loc
//     * getServerPort()                           8480
//     * getServletPath()           yes            /test?
//     * getParameterNames()        yes            [p 2, p 1]
//     * getParameter("p 1")        yes            c d
//     */
//    @Override
//    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
//        LOGGER.info("==== HelloServlet doGet ====");
//        String user = req.getParameter("user");
//        if (user == null) {
//            res.getWriter().println("Hello Servlet!");
//        } else {
//            res.getWriter().println("Hello " + user);
//        }
//    }
//
//    /**
//     * 如果沒 override doPost()，則 request 是 HTTP POST 時，會發生 HTTP Error 405 Method Not Allowed
//     *
//     * ==== Using HttpServletRequest ====
//     * 1. Getting Request Parameters
//     *   POST /hello HTTP/1.1
//     *   Host: localhost:8080
//     *   user=daniel
//     * -> request.getParameter("user");
//     */
////    @Override
////    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
////    }
//
//}
