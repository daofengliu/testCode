package idv.spring.ioc.ch02annotation;

/**
 * ==== Annotation-based configuration ====
 * Spring 2.5 introduced support for annotation-based configuration metadata.
 * Instead of using XML to describe a bean wiring, you can move the bean configuration into the component class itself
 *   by using annotations on the relevant class, method, or field declaration.
 * For example:
 *   Spring 2.0
 *     @Required
 *   Spring 2.5
 *     @Autowired, @Qualifier
 *     @PostConstruct, @PreDestroy, @Resource (JSR-250, javax.annotation)
 *   Spring 3.0
 *     @Primary
 *     @Inject, @Named (JSR-330, javax.inject)
 *   Spring 5.0
 *     @Nullable
 *
 * _Spring 2.5 提供 annotation-based 設定，取代使用 XML 描述 bean 的注入關係
 * _可以使用 @Autowired, @Qualifier, ...以及 JSR-250 annotation 直接設定在 java class
 * _ps. @see idv.spring.ioc.ch01xml.MyXmlApplicationContext 的 autowired(...)
 *      _和 idv/spring/ioc/ch01xml/beansConfig.xml 的 == autowired == 設定
 *
 * By default, Spring annotation wiring is not turned on in Spring Framework.
 * Therefore, you need to enable it before you can use the Spring annotation-based wiring in the Spring Configuration file.
 *
 *     <context:annotation-config />
 *
 * Once the tag <context:annotation-config /> is configured you have the authority to start annotating your code.
 * It will indicate that the Spring should automatically wire the values into properties methods and constructors.
 * _Spring 預設沒有啟動 annotation wiring 功能，必須在 application context XML 設定檔設定 <context:annotation-config />
 * _Spring 會根據設定在 java class 的 annotation 做 bean 相依的注入
 * _ps. 但是還是需要自己定義各個 bean，只是 bean 之間的相依的 wiring 由 Spring 處理
 *
 * ==== @Required ====
 * @see - RequiredAnnotationBeanPostProcessor
 * This annotation indicates that the affected bean property must be populated at configuration time,
 *   through an explicit property value in a bean definition or through autowiring.
 * The container throws an exception if the affected bean property has not been populated.
 * This allows for eager and explicit failure, avoiding NullPointerException instances or the like later on.
 *
 * ps. The @Required annotation is formally deprecated as of Spring Framework 5.1,
 *     in favor of using constructor injection for required settings (or a custom implementation of InitializingBean.afterPropertiesSet() along with bean property setter methods).
 *     _Spring 5.1 已 deprecated
 *     _對於必須設值的 field，使用 constructor injection 比較好
 *
 *   == field injection ==
 *   @Autowired
 *   private FooService fooService;
 *
 *   == setter injection ==
 *   private FooService fooService;
 *
 *   @Autowired
 *   public void setFooService(FooService fooService) {
 *       this.fooService = fooService
 *   }
 *
 *   == constructor injection ==
 *   private final FooService fooService;
 *
 *   @Autowired
 *   public MyComponent(FooService fooService) {
 *       this.fooService = fooService;
 *   }
 *
 * The only way to declare your Service final is by using the constructor injection,
 *   which replaces the @Required annotation because it forces the user of your class to instantiate it with the required services.
 * The user does not have to be Spring, it could be a simple unit test as well
 * You should use constructor injection for mandatory dependencies and setter injections for optional dependencies instead of field injection.
 * Some reasons why:
 *   1. It makes it clear to everybody which dependencies are required
 *   2. It makes testing easier
 *   3. You can make your objects immutable
 * _使用 constructor injectioni 是唯一可以宣告 field 為 final 的方式
 * _對於必要的相依關係，建議使用 constructor injection，對於非必要的相依關係，使用 setter injection
 *
 * ==== @Autowired ====
 * You can apply the @Autowired annotation to fields, setter methods, constructors
 * By default, Spring resolves @Autowired entries by type.
 * If more than one beans of the same type are available in the container,
 *   the framework will throw a fatal exception indicating that more than one bean is available for autowiring.
 * _@@Autowired 可以用在 field, setter, constructor
 * _@Autowired 預設為 by type 做 dependency injection (XML 設定可以 byName, byType, constructor)
 * _若 @Autowired 註解的類別有超過一個以上的 bean，Spring 會拋出 NoUniqueBeanDefinitionException
 *
 * _ps. @Autowired 實做為 AutowiredAnnotationBeanPostProcessor
 *      _該類別實做 MergedBeanDefinitionPostProcessor
 *      _Spring 的 application context 啟動後會執行 AbstractApplicationContext 的 refresh()
 *      _refresh() 會呼叫 registerBeanPostProcessors(beanFactory) 完成對 AutowiredAnnotationBeanPostProcessor 的註冊
 *      _refresh() 會呼叫 finishBeanFactoryInitialization(beanFactory) 對非延遲 singleton bean 進行初始化
 *
 *   == Autowiring by @Qualifier ==
 *   This annotation is used to avoid conflicts in bean mapping and we need to provide the bean name that will be used for autowiring.
 *   This way we can avoid issues where multiple beans are defined for same type.
 *   This annotation usually works with the @Autowired annotation.
 *   _@Qualifier 常常會搭配 @Autowired 使用
 *   _可以避免 @Autowired 做 dependency injection 時，遇到 NoUniqueBeanDefinitionException
 *
 *
 * ps. JSR 330’s @Inject annotation can be used in place of Spring’s @Autowired annotation
 *     _@Inject 可以取代 @Autowired
 *
 * *****************************************************************************
 * The @Autowired, @Inject, @Value, and @Resource annotations are handled by Spring BeanPostProcessor implementations.
 * This means that you cannot apply these annotations within your own BeanPostProcessor or BeanFactoryPostProcessor types (if any).
 * These types must be 'wired up' explicitly by using XML or a Spring @Bean method.
 * *****************************************************************************
 *
 * ==== @Primary ====
 *
 *
 * *****************************************************************************
 * ps.
 *   Annotation injection is performed before XML injection.
 *   Thus, the XML configuration overrides the annotations for properties wired through both approaches.
 *   _XML 設定會覆蓋 annotation 設定
 * *****************************************************************************
 *
 * Spring provides further stereotype annotations: @Component, @Service, and @Controller.
 * @Component is a generic stereotype for any Spring-managed component.
 * @Repository, @Service, and @Controller are specializations of @Component for more
 *   specific use cases, for example, in the persistence, service, and presentation
 *   layers, respectively.
 * Therefore, you can annotate your component classes with @Component, but by
 *   annotating them with @Repository, @Service, or @Controller instead, your
 *   classes are more properly suited for processing by tools or associating with aspects.
 * For example, these stereotype annotations make ideal targets for pointcuts.
 * It is also possible that @Repository, @Service, and @Controller may carry
 *   additional semantics in future releases of the Spring Framework.
 * Thus, if you are choosing between using @Component or @Service for your service
 *   layer, @Service is clearly the better choice.
 * Similarly, as stated above, @Repository is already supported as a marker for
 *   automatic exception translation in your persistence layer.
 *
 *   @Component     generic stereotype for any Spring-managed component
 *   @Repository    stereotype for persistence layer
 *   @Service       stereotype for service layer
 *   @Controller    stereotype for presentation layer (spring-mvc)
 *
 * To autodetect these classes and register the corresponding beans, you need to add
 *   <context:component-scan base-package="..." /> to spring configuration
 *
 *   記得設定 <context:component-scan base-package="idv.spring.ioc.ch03annotation" />
 *
 * 1. ch02 使用 annotation，但是 bean 的設定還是在 XML 裡，故使用 @Component 減少在 XML 的設定
 * 2. 在 applicationContext.xml 要設定 <context:component-scan base-package="..." />
 */
public class MyAnnotationBasedApplicationContext {
}
